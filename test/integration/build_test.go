package integration

import (
	"os"
	"testing"

	"github.com/JHashimoto0518/ttlx/internal/config"
	"github.com/JHashimoto0518/ttlx/internal/generator"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestBuild_SimpleConfig(t *testing.T) {
	// 1. YAML読み込み
	cfg, err := config.LoadConfig("../fixtures/valid/simple.yml")
	require.NoError(t, err)

	// 2. バリデーション
	err = config.Validate(cfg)
	require.NoError(t, err)

	// 3. TTL生成
	ttl, err := generator.Generate(cfg, "simple.yml")
	require.NoError(t, err)

	// 4. 生成されたTTLの検証
	assert.Contains(t, ttl, "Generated by ttlx")
	assert.Contains(t, ttl, "connect 'bastion.example.com:22")
	assert.Contains(t, ttl, "ssh user2@10.0.0.50")
	assert.Contains(t, ttl, ":SUCCESS")
	assert.Contains(t, ttl, ":CLEANUP")
}

func TestBuild_FullConfig(t *testing.T) {
	// 1. YAML読み込み
	cfg, err := config.LoadConfig("../fixtures/valid/full.yml")
	require.NoError(t, err)

	// 2. バリデーション
	err = config.Validate(cfg)
	require.NoError(t, err)

	// 3. TTL生成
	ttl, err := generator.Generate(cfg, "full.yml")
	require.NoError(t, err)

	// 4. 生成されたTTLの検証
	assert.Contains(t, ttl, "Generated by ttlx")
	assert.Contains(t, ttl, "timeout = 60")
	assert.Contains(t, ttl, "connect 'bastion.example.com:22")
	assert.Contains(t, ttl, "getenv 'BASTION_PASSWORD' password")
	assert.Contains(t, ttl, "sendln 'su - root'")
	assert.Contains(t, ttl, "sendln 'cd /var/log'")
	assert.Contains(t, ttl, "ssh user2@10.0.0.50")
	assert.Contains(t, ttl, "sendln 'ps aux'")
	assert.Contains(t, ttl, "sendln 'df -h'")
}

func TestBuild_InvalidConfig(t *testing.T) {
	tests := []struct {
		name     string
		file     string
		errorMsg string
	}{
		{
			name:     "missing version",
			file:     "../fixtures/invalid/missing-version.yml",
			errorMsg: "version field is required",
		},
		{
			name:     "missing profiles",
			file:     "../fixtures/invalid/missing-profiles.yml",
			errorMsg: "at least one profile must be defined",
		},
		{
			name:     "invalid profile reference",
			file:     "../fixtures/invalid/invalid-profile-ref.yml",
			errorMsg: "profile 'nonexistent' not found",
		},
		{
			name:     "invalid auth type",
			file:     "../fixtures/invalid/invalid-auth.yml",
			errorMsg: "invalid auth type",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg, err := config.LoadConfig(tt.file)
			require.NoError(t, err)

			err = config.Validate(cfg)
			require.Error(t, err)
			assert.Contains(t, err.Error(), tt.errorMsg)
		})
	}
}

func TestBuild_EndToEnd(t *testing.T) {
	// 完全なエンドツーエンドテスト: YAML読み込み → バリデーション → TTL生成 → ファイル出力
	configPath := "../fixtures/valid/simple.yml"
	outputPath := "/tmp/test_output.ttl"
	defer func() { _ = os.Remove(outputPath) }()

	// 1. YAML読み込み
	cfg, err := config.LoadConfig(configPath)
	require.NoError(t, err)

	// 2. バリデーション
	err = config.Validate(cfg)
	require.NoError(t, err)

	// 3. TTL生成
	ttl, err := generator.Generate(cfg, "simple.yml")
	require.NoError(t, err)

	// 4. ファイル出力
	err = os.WriteFile(outputPath, []byte(ttl), 0o644)
	require.NoError(t, err)

	// 5. ファイルが作成されたことを確認
	info, err := os.Stat(outputPath)
	require.NoError(t, err)
	assert.Greater(t, info.Size(), int64(0))

	// 6. ファイル内容を読み込んで検証
	content, err := os.ReadFile(outputPath)
	require.NoError(t, err)
	assert.Contains(t, string(content), "Generated by ttlx")
}
