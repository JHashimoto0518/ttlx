package generator

import (
	"strings"
	"testing"

	"github.com/JHashimoto0518/ttlx/internal/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// boolPtr returns a pointer to a bool value.
func boolPtr(b bool) *bool {
	return &b
}

func TestGenerate_Simple(t *testing.T) {
	cfg, err := config.LoadConfig("../../test/fixtures/valid/simple.yml")
	require.NoError(t, err)

	results, err := GenerateAll(cfg, "simple.yml")
	require.NoError(t, err)

	// テストで最初のルートを取得
	var ttl string
	for _, result := range results {
		ttl = result
		break
	}

	// ヘッダーの確認
	assert.Contains(t, ttl, "Generated by ttlx")
	assert.Contains(t, ttl, "Source: simple.yml")

	// 変数定義の確認
	assert.Contains(t, ttl, "timeout = 30")

	// 接続処理の確認（最初のステップ）
	assert.Contains(t, ttl, ":CONNECT_BASTION")
	assert.Contains(t, ttl, "getpassword 'passwords.dat' 'bastion' password")
	assert.Contains(t, ttl, "strconcat connectcmd 'bastion.example.com:22 /ssh /auth=password /user=user1")
	assert.Contains(t, ttl, "strconcat connectcmd password")
	assert.Contains(t, ttl, "connect connectcmd")

	// 2番目のステップの確認（ポート指定含む）
	assert.Contains(t, ttl, "sendln 'ssh user2@10.0.0.50 -p 22'")
	assert.Contains(t, ttl, "wait 'password:'")
	assert.Contains(t, ttl, "getpassword 'passwords.dat' 'target' password")

	// エラーハンドリングの確認
	assert.Contains(t, ttl, ":ERROR_CONNECT_BASTION")
	assert.Contains(t, ttl, ":TIMEOUT_BASTION")
	assert.Contains(t, ttl, ":TIMEOUT_TARGET")
	assert.Contains(t, ttl, ":CLEANUP")

	// 成功終了の確認
	assert.Contains(t, ttl, ":SUCCESS")
}

func TestGenerate_Full(t *testing.T) {
	cfg, err := config.LoadConfig("../../test/fixtures/valid/full.yml")
	require.NoError(t, err)

	results, err := GenerateAll(cfg, "full.yml")
	require.NoError(t, err)

	// テストで最初のルートを取得
	var ttl string
	for _, result := range results {
		ttl = result
		break
	}

	// ヘッダーの確認
	assert.Contains(t, ttl, "Generated by ttlx")
	assert.Contains(t, ttl, "Source: full.yml")

	// カスタムタイムアウトの確認
	assert.Contains(t, ttl, "timeout = 60")

	// 接続処理の確認（パスワードファイル認証）
	assert.Contains(t, ttl, ":CONNECT_BASTION")
	assert.Contains(t, ttl, "getpassword 'passwords.dat' 'bastion' password")
	assert.Contains(t, ttl, "strconcat connectcmd 'bastion.example.com:22 /ssh /auth=password /user=user1")
	assert.Contains(t, ttl, "strconcat connectcmd password")
	assert.Contains(t, ttl, "connect connectcmd")

	// コマンド実行の確認
	assert.Contains(t, ttl, "sendln 'su - root'")
	assert.Contains(t, ttl, "sendln 'cd /var/log'")

	// 2番目のステップ（公開鍵認証）の確認（ポート指定含む）
	assert.Contains(t, ttl, "sendln 'ssh user2@10.0.0.50 -p 2222'")
	assert.Contains(t, ttl, "sendln 'ps aux'")
	assert.Contains(t, ttl, "sendln 'df -h'")
}

func TestGenerate_WithKeyfile(t *testing.T) {
	cfg := &config.Config{
		Version: "1.0",
		Profiles: map[string]*config.Profile{
			"server": {
				Host:         "server.example.com",
				Port:         22,
				User:         "user",
				PromptMarker: "$ ",
				Auth: &config.Auth{
					Type: "keyfile",
					Path: "~/.ssh/id_rsa",
				},
			},
		},
		Routes: map[string][]*config.RouteStep{
			"test-route": {
				{Profile: "server"},
			},
		},
		Options: &config.Options{
			Timeout: 30,
		},
	}

	results, err := GenerateAll(cfg, "test.yml")
	require.NoError(t, err)

	ttl := results["test-route"]

	// 公開鍵認証の確認
	assert.Contains(t, ttl, "connect 'server.example.com:22 /ssh /auth=keyfile /user=user /keyfile=~/.ssh/id_rsa'")
	// パスワード入力がないことを確認
	assert.NotContains(t, ttl, "passwordbox")
	assert.NotContains(t, ttl, "getenv")
}

func TestGenerate_PasswordValue(t *testing.T) {
	cfg := &config.Config{
		Version: "1.0",
		Profiles: map[string]*config.Profile{
			"server": {
				Host:         "server.example.com",
				Port:         22,
				User:         "user",
				PromptMarker: "$ ",
				Auth: &config.Auth{
					Type:  "password",
					Value: "secret123",
				},
			},
		},
		Routes: map[string][]*config.RouteStep{
			"test-route": {
				{Profile: "server"},
			},
		},
		Options: &config.Options{
			Timeout: 30,
		},
	}

	results, err := GenerateAll(cfg, "test.yml")
	require.NoError(t, err)

	ttl := results["test-route"]

	// 直接指定されたパスワードの確認 - connect コマンドに含まれる
	assert.Contains(t, ttl, "connect 'server.example.com:22 /ssh /auth=password /user=user /passwd=secret123'")
	// 別途の sendln でパスワード送信がないことを確認
	assert.NotContains(t, ttl, "sendln 'secret123'")
}

func TestGenerate_Components(t *testing.T) {
	t.Run("generateHeader", func(t *testing.T) {
		header := generateHeader("test.yml", "test-route")
		assert.Contains(t, header, "Generated by ttlx")
		assert.Contains(t, header, "Source: test.yml")
	})

	t.Run("generateVariables", func(t *testing.T) {
		cfg := &config.Config{
			Options: &config.Options{
				Timeout: 60,
			},
		}
		vars := generateVariables(cfg)
		assert.Contains(t, vars, "timeout = 60")
	})

	t.Run("generateVariables with default", func(t *testing.T) {
		cfg := &config.Config{}
		vars := generateVariables(cfg)
		assert.Contains(t, vars, "timeout = 30")
	})
}

func TestGenerate_AutoDisconnect(t *testing.T) {
	tests := []struct {
		name           string
		autoDisconnect *bool
		routeSteps     int
		expectClosett  bool
		expectExit     int // 期待される exit コマンドの数
		expectEnd      bool
	}{
		{
			name:           "auto_disconnect: true (1 step)",
			autoDisconnect: boolPtr(true),
			routeSteps:     1,
			expectClosett:  true,
			expectExit:     0,
			expectEnd:      true,
		},
		{
			name:           "auto_disconnect: true (2 steps)",
			autoDisconnect: boolPtr(true),
			routeSteps:     2,
			expectClosett:  true,
			expectExit:     1,
			expectEnd:      true,
		},
		{
			name:           "auto_disconnect: false",
			autoDisconnect: boolPtr(false),
			routeSteps:     2,
			expectClosett:  false,
			expectExit:     0,
			expectEnd:      true,
		},
		{
			name:           "auto_disconnect: not specified (default)",
			autoDisconnect: nil,
			routeSteps:     2,
			expectClosett:  false,
			expectExit:     0,
			expectEnd:      true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// テストケースに応じた Config を構築
			cfg := buildTestConfig(tt.autoDisconnect, tt.routeSteps)

			// TTL生成
			results, err := GenerateAll(cfg, "test.yml")
			require.NoError(t, err)

			result := results["test-route"]

				// closett の存在チェック（成功終了部分のみ）
			// SUCCESS セクションを抽出
			successIndex := strings.Index(result, ":SUCCESS")
			errorIndex := strings.Index(result, ":ERROR")
			successSection := ""
			if successIndex != -1 && errorIndex != -1 {
				successSection = result[successIndex:errorIndex]
			}

			if tt.expectClosett {
				assert.Contains(t, successSection, "closett", "expected 'closett' in SUCCESS section")
			} else {
				assert.NotContains(t, successSection, "closett", "unexpected 'closett' in SUCCESS section")
			}

			// exit コマンドの数チェック
			exitCount := strings.Count(result, "sendln 'exit'")
			assert.Equal(t, tt.expectExit, exitCount, "expected %d 'exit' commands, got %d", tt.expectExit, exitCount)

			// end の存在チェック
			if tt.expectEnd {
				assert.Contains(t, result, "end", "expected 'end' in generated TTL")
			}
		})
	}
}

// buildTestConfig builds a test configuration.
func buildTestConfig(autoDisconnect *bool, routeSteps int) *config.Config {
	cfg := &config.Config{
		Version:  "1.0",
		Profiles: make(map[string]*config.Profile),
		Routes:   make(map[string][]*config.RouteStep),
		Options: &config.Options{
			Timeout:        30,
			AutoDisconnect: autoDisconnect,
		},
	}

	// プロファイルとルートを動的に生成
	route := make([]*config.RouteStep, 0)
	for i := 0; i < routeSteps; i++ {
		profileName := "server" + string(rune('a'+i))
		cfg.Profiles[profileName] = &config.Profile{
			Host:         "example.com",
			Port:         22,
			User:          "user",
			PromptMarker: "$ ",
			Auth: &config.Auth{
				Type:         "password",
				PasswordFile: "passwords.dat",
			},
		}

		// 2段目以降はpassword_promptが必要
		if i > 0 {
			cfg.Profiles[profileName].Auth.PasswordPrompt = "password:"
		}

		route = append(route, &config.RouteStep{
			Profile: profileName,
		})
	}

	cfg.Routes["test-route"] = route
	return cfg
}
