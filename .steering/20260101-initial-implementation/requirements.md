# 初回実装の要求定義

## 概要

本ドキュメントでは、ttlx プロジェクトの初回実装（Phase 1 MVP）における要求事項を定義します。永続的ドキュメント（`docs/product-requirements.md`）で定義された Phase 1 機能を実現するための、具体的な実装要件を記述します。

---

## 実装対象機能

### Phase 1 (MVP) 機能

以下の機能を実装します：

1. **YAML設定ファイルの読み込み**
   - YAML ファイルのパース
   - 設定データの構造化（Config モデルへの変換）

2. **基本的な多段SSH接続（2段のみ）**
   - 踏み台サーバー → 目的サーバーの2段接続
   - 各段階での接続処理のTTL生成

3. **パスワード認証・公開鍵認証の両対応**
   - パスワード認証（環境変数、実行時入力）
   - 公開鍵認証（秘密鍵ファイルパス指定）

4. **接続後の任意コマンド実行**
   - 各ルートステップでのコマンド実行
   - コマンドリストの順次実行

5. **TTLスクリプトの生成**
   - YAML設定から TTL コードを生成
   - エラーハンドリングコードを含む
   - ファイル出力

6. **基本的なバリデーション**
   - YAML構文チェック
   - 必須項目の存在確認
   - プロファイル参照の整合性チェック

7. **CLIコマンド**
   - `ttlx build <config.yml>` コマンド
   - `ttlx validate <config.yml>` コマンド
   - `ttlx version` コマンド
   - `ttlx help` コマンド

---

## 実装しない機能（Phase 2以降）

以下の機能は今回の実装対象外です：

- ❌ 3段以上の多段SSH接続
- ❌ グローバルプロファイルのインポート
- ❌ エラーハンドリングオプション（リトライ、タイムアウト制御）
- ❌ 対話的セットアップ（`ttlx init`）
- ❌ 変数展開機能
- ❌ TTL差分表示機能（`ttlx diff`）
- ❌ メタデータファイル管理

---

## ユーザーストーリー（初回実装）

### US-MVP-001: 基本的なYAML設定ファイルからTTL生成

**As a** インフラエンジニア

**I want to** 踏み台サーバー経由の2段接続をYAMLで定義し、TTLを生成したい

**So that** 手作業でTTLスクリプトを書く手間を省ける

**受け入れ条件**:
- YAML設定ファイルを作成できる（プロファイル2つ、ルート2段）
- `ttlx build config.yml` でTTLが生成される
- 生成されたTTLをTera Termで実行すると、2段接続が成功する
- 各段階でコマンドが実行される

**例**:
```yaml
version: "1.0"

profiles:
  bastion:
    host: bastion.example.com
    user: user1
    auth:
      type: password
      env: BASTION_PASS

  target:
    host: 10.0.0.50
    user: user2
    auth:
      type: keyfile
      path: ~/.ssh/id_rsa

route:
  - profile: bastion
    commands:
      - su - root

  - profile: target
    commands:
      - ls -la
      - pwd
```

---

### US-MVP-002: バリデーションによるエラー検出

**As a** 全てのユーザー

**I want to** 設定ファイルのエラーを事前に検出したい

**So that** TTL生成前に問題を修正できる

**受け入れ条件**:
- `ttlx validate config.yml` でバリデーションが実行される
- 構文エラー、必須項目の欠落を検出できる
- プロファイル参照が不正な場合、エラーを表示する
- エラーメッセージは分かりやすく、行番号を含む

---

### US-MVP-003: パスワード認証と公開鍵認証の使い分け

**As a** サーバー管理者

**I want to** プロファイルごとに認証方式を選択したい

**So that** 様々な認証方式のサーバーに対応できる

**受け入れ条件**:
- パスワード認証を環境変数から読み込める
- パスワード認証を実行時入力できる（`prompt: true`）
- 公開鍵認証で秘密鍵ファイルを指定できる
- 生成されたTTLで、各認証方式が正しく動作する

---

## 機能要件

### FR-MVP-001: YAML設定ファイルの読み込み

**実装内容**:
- YAML ファイルの読み込み（`gopkg.in/yaml.v3` 使用）
- `Config` 構造体へのアンマーシャル
- ファイルが存在しない場合のエラーハンドリング
- YAML構文エラーの検出とユーザーフレンドリーなエラーメッセージ

**検証方法**:
- ユニットテスト: 正常系YAMLファイルの読み込み
- ユニットテスト: YAML構文エラーの検出
- ユニットテスト: ファイル不存在のエラーハンドリング

---

### FR-MVP-002: バリデーション

**実装内容**:
- `version` フィールドの存在確認
- `profiles` に少なくとも1つのプロファイルが定義されているか
- `route` に少なくとも1つのステップが定義されているか
- `route` の各ステップで指定された `profile` が `profiles` に存在するか
- 認証設定が正しいか（`type` に応じた必須フィールド）
- ホスト名、ポート番号が妥当な形式か

**検証方法**:
- ユニットテスト: 各バリデーションルールのテスト
- 統合テスト: 不正なYAMLファイルでのバリデーション失敗

---

### FR-MVP-003: TTL生成

**実装内容**:
- TTL ヘッダーコメントの生成（生成元ファイル名、生成日時）
- 変数定義の生成（`timeout` など）
- 各ルートステップの接続処理生成
  - 最初のステップ: `connect` コマンド
  - 2番目以降: `sendln 'ssh ...'` コマンド
- 認証処理の生成（パスワード/公開鍵）
- コマンド実行処理の生成
- エラーハンドリングコードの生成
- 正常終了・異常終了処理の生成

**検証方法**:
- ユニットテスト: 各コンポーネントのTTL生成
- 統合テスト: 完全なYAMLからTTL生成
- 統合テスト: 生成されたTTLが期待通りの内容か

---

### FR-MVP-004: CLIコマンド

**実装内容**:
- `ttlx build <config.yml>` コマンド
  - `-o, --output` フラグ（出力先指定）
  - `--dry-run` フラグ（画面表示のみ）
- `ttlx validate <config.yml>` コマンド
- `ttlx version` コマンド
- `ttlx help` コマンド

**検証方法**:
- 統合テスト: 各コマンドの実行
- 統合テスト: フラグの動作確認

---

## 非機能要件

### NFR-MVP-001: パフォーマンス

- 100KB以下のYAMLファイルを1秒以内に処理
- メモリ使用量50MB以下

**検証方法**:
- パフォーマンステスト: 処理時間の計測
- プロファイリング: メモリ使用量の確認

---

### NFR-MVP-002: 可用性

- 生成されたTTLスクリプトが、Tera Term 4.106以降で動作する

**検証方法**:
- 手動テスト: Tera Termでの動作確認

---

### NFR-MVP-003: 保守性

- ユニットテストカバレッジ80%以上
- コードが `golangci-lint` を通過する

**検証方法**:
- テストカバレッジレポート
- CI での自動チェック

---

### NFR-MVP-004: セキュリティ

- パスワードを平文で記述した場合、警告を表示
- 環境変数からパスワードを読み込む機能を提供

**検証方法**:
- ユニットテスト: 平文パスワード警告の表示
- ユニットテスト: 環境変数読み込み

---

## 制約事項

### 技術的制約

1. **Go 1.21以降**: Go言語で実装
2. **2段接続のみ**: 3段以上の接続は Phase 2
3. **YAML形式のみ**: JSON、TOML等は非対応
4. **オフライン動作**: インターネット接続不要

### ビジネス制約

1. **開発期間**: 初回実装は2週間程度を想定（目安）
2. **シンプルさ優先**: 複雑な機能よりも、基本機能の確実な動作を優先

---

## 成功基準

### 最低限の成功基準（Must Have）

- [ ] YAML設定ファイルからTTLが生成できる
- [ ] 2段SSH接続のTTLが正しく動作する
- [ ] パスワード認証と公開鍵認証の両方が動作する
- [ ] バリデーションが基本的なエラーを検出する
- [ ] `ttlx build` コマンドが動作する
- [ ] ユニットテストカバレッジ80%以上

### あると良い成功基準（Nice to Have）

- [ ] ユーザーフレンドリーなエラーメッセージ
- [ ] `--dry-run` フラグの実装
- [ ] CLI出力のカラー表示
- [ ] プログレス表示

---

## テスト計画

### ユニットテスト

- `internal/config`: YAML読み込み、バリデーション
- `internal/generator`: TTL生成
- `internal/cli`: CLIコマンド

### 統合テスト

- `test/integration`: YAML → TTL生成の全体フロー
- フィクスチャ使用: `test/fixtures/valid/`, `test/fixtures/invalid/`

### 手動テスト

- 生成されたTTLをTera Termで実行
- 実際のサーバーへの接続確認（テスト環境）

---

## リスクと対策

### リスク1: TTL構文の理解不足

**発生確率**: 中

**影響度**: 高

**対策**:
- Tera Term マクロのドキュメントを熟読
- 簡単なTTLスクリプトを手動で作成し、動作確認
- 既存のTTLスクリプトを参考にする

---

### リスク2: 認証処理の複雑さ

**発生確率**: 中

**影響度**: 中

**対策**:
- パスワード認証から実装（シンプル）
- 公開鍵認証は後から追加
- テスト環境で十分に動作確認

---

### リスク3: エラーハンドリングの漏れ

**発生確率**: 中

**影響度**: 中

**対策**:
- `errcheck` リンターで検証
- すべてのエラーパスをテスト
- ユニットテストで網羅

---

## まとめ

本ドキュメントでは、ttlx の初回実装（Phase 1 MVP）における要求事項を定義しました。基本的な2段SSH接続、両認証方式、TTL生成、バリデーション機能を実現することで、ユーザーが実用的にttlxを使用できるようになります。

次のステップとして、実装設計書（`design.md`）で具体的な実装方針を決定します。
